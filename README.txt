														     ΕΡΓΑΣΙΑ 2 ΠΡΟΓΡΑΜΜΑΤΙΣΜΟΣ ΣΥΣΤΗΜΑΤΟΣ
														     ΜΑΡΙΑ ΠΑΡΑΣΚΕΥΟΠΟΥΛΟΥ 	-  sdi1800155

Έχουν χρησιμοποιηθεί κομμάτια κώδικα διαλέξεων, από τις διαλέξεις 5 και 6.

Επεξήγηση φακέλων:
- big_content : 		φάκελος για test
- big_dir : 			φάκελος για test
- classes : 			αρχεία των κλάσεων ExecQueue και MutexDict
- ClientsFileSystems :	εδώ αποθηκεύονται τα file systems των πελατών
- include : 			headers
- modules :				αρχεία με βοηθητικές συναρτήσεις του server και του client

classes
execQueue.h και execQueue.cpp
struct file : 		δομή για την περιγραφή ενός αρχείου. Περιέχει το όνομα και μέγεθος αρχείου και τον περιγραφέα αρχείου του socket του πελάτη που ζήτησε τον κατάλογο του 
					αρχείου. 
class ExecQueue : 	υλοποίηση της ουράς εκτέλεσης. Περιέχει μια queue της STL με στοιχεία struct file*, το μέγεθός της δηλαδή τα στοιχεία που περιέχει την current χρονική
					στιγμή και το μέγιστο πλήθος στοιχείων που χωράει (δίνεται ώς όρισμα). Οι λειτουργίες push και pop γίνονται με τη χρήση ενός mutex για την πρόσβαση στην
					ουρά. Τα communication threads κάνουν push και τα worker threads κάνουν pop. Χρησιμοποιούνται δύο μεταβλητές συνθήκης ώστε όταν η ουρά είναι γεμάτη, το
					communication thread απελευθερώνει τον mutex και περιμένει ένα worker thread να απελευθερώσει χώρο και να δώσει σήμα. Αντίστοιχα αν η ουρά είναι άδεια.
mutexDict.h και mutexDict.cpp
class MutexDict :	αποθήκευση ενός mutex για κάθε socket πελάτη. "Ο server θα πρέπει να εξασφαλίζει κατά τη διάρκεια εκτέλεσης του, ότι στο socket κάθε πελάτη γράφει δεδομένα
					μόνο ένα worker thread τη φορά, μέχρι να γράψει ολόκληρο το αρχείο που του αντιστοιχεί, παρόλο που τα writes στο socket γίνονται ένα block τη φορά." Έτσι
					κάθε worker thread πριν στείλει δεδομένα στο socket του πελάτη παίρνει με τον file descriptor του socket έναν mutex από το dictionary και τον κλειδώνει 
					προκειμένου να μη μπλεχτούν τα δεδομένα με αυτά που ενδεχομένως αποστέλλει κάποιο άλλο worker thread (ενός αρχείου του ίδιου καταλόγου).
					

dataServer.cpp
- signal handler για τοτ SIGINT για απελευθέρωση πόρων και κλείσιμο του socket πριν τον τερματισμό.
- δημιουργία socket, bind, listen και δημιουργία worker threads, τόσων όσο το thread_pool_size που δίνεται ως όρισμα. (συνάρτηση work επεξηγείται παρακάτω). Δεν θεώρησα σημαντικό 
  το να δημιουργήσω κάποια δομή "thread pool" επειδή τα worker threads τρέχουν διαρκώς μέχρι τον τερματισμό της διεργασίας. Είναι marked ως detached ώστε όταν τερματίσουν να 
  απελευθερωθούν αυτόματα οι πόροι τους στο σύστημα.
- while loop : 		accepts connection with client. Η accept επιστρέφει sockfd.
					Δημιουργία mutex για αυτό το sockfd και εισαγωγή του στο mutex dictionary.
					Δημιουργία communication thread για αυτόν τον πελάτη. (συνάρτηση communicate επεξηγείται παρακάτω).

modules
communication.cpp
Διαβάζει το όνομα του καταλόγου προς αντιγραφή από το socket και διαβάζει αναδρομικά τον κατάλογο, βρίσκοντας αρχεία και αποθηκεύοντας τα ως σχετικά προς τον κατάλογο μονοπάτια 
στην ουρά εκτέλεσης. (Ουσιαστικά αποθηκεύει κάθε αρχείο ως δομή struct file, όπου name είναι το μονοπάτι, ...). Στο τέλος εισάγει στην ουρά ένα struct file με name "end" και ίδιο
περιγραφέα αρχείου με των προηγουμένων αρχείων προκειμένου ο πελάτης να γνωρίζει πότε πρέπει να σταματίσει να περιμένει για αρχεία.

worker.cpp
Παίρνει ένα αρχείο από την ουρά εκτέλεσης. Στη δομή αρχείου περιέχεται ο file descriptor του πελάτη που το ζητάει, τον οποίο χρησιμοποιεί για να πάρει από το mutex dictionary 
τον mutex του socket και να τον κλειδώσει. Στη συνέχεια γράφει στο socket του πελάτη, δεσμεύοντας τόσα bytes όσα ορίζει το πρωτόκολλο:
																
																		   ΠΡΩΤΟΚΟΛΛΟ
																	 filename : 1024 bytes
																	   filesize : 4 bytes
																	contents : ανά block_size

Προσοχή!! Το μέγεθος του αρχείου δεν είναι το actual μέγεθος του αρχείου, αλλά είναι στρογγυλοποιημένο προς τα πάνω σε πολλαπλάσιο του block_size. (Περιγράφεται παρακάτω γιατί.)

Όταν το worker thread λάβει το struct file με το όνομα "end", στέλνει το πρώτο πεδίο, αγνοεί τα υπόλοιπα και ξεκλειδώνει τον mutex.


remoteClient.cpp
- Κάθε πελάτης δημιουργεί αρχικά έναν κατάλογο ("σύστημα αρχείων") μέσα στον υπάρχοντα φάκελο client/ClientsFileSystems με όνομα FileSystem και έναν τυχαίο αριθμό στο τέλος.		
- δημιουργία socket, connect και γράψιμο ονόματος directory στο socket του server. Το όνομα του directory είναι σχετικό μονοπάτι από την πλευρά του εξυπηρέτη.
- while loop :		διάβασμα από το socket σύμφωνα με το πρωτόκολλο.
					Ο πελάτης έτσι γνωρίζοντας το πρωτόκολλο ξέρει ότι τα 100 πρώτα bytes περιέχουν το μονοπάτι του αρχείου, τα επόμενα 4 το μέγεθος του αρχείου και έπειτα
					τα περιεχόμενα.
					Διαβάζει όλο το περιεχόμενο του αρχείου σε έναν buffer, δηλαδή τόσα bytes όσα περιγράφει το filesize που έχει διαβάσει από το socket προηγουμένως.
					Επειδή ο εξυπηρέτης αποστέλλει δεδομένα ανα block μεγέθους block_size, είναι πιθανό να στείλει κενά bytes στο τέλος. Έτσι, για να τα συμπεριλάβει ο client 
					στο περιεχόμενο και να μην διαβαστούν στην επόμενη επανάληψη ως όνομα ή size αναταράσσοντας τη διαδικασία, ο εξυπηρέτης έχει φροντίσει το filesize να είναι 
					πολλαπλάσιο του block_size.
					
					Το όνομα του αρχείου τροποποιείται (adjust_filename) ώστε αν ο πελάτης έχει ζητήσει φάκελο αναφερόμενος σε αυτόν ώς σχετικό μονομάτι, παράδειγμα του piazza: 
					dir1/dir2/dir3, τότε να αντιγράψει μόνο τον φάκελο dir3, χωρίς να δημιουργήσει τους dir1, dir2.

					Όταν διαβάσει το όνομα "end", αν έχουν διαβαστεί και αντιγραφεί τόσα αρχεία όσα λέει το πεδίο size τότε τερματίζει το loop αλλιώς συνεχίζεται μέχρι να 
					συμπληρωθούν.

modules
folderCreation.cpp
Η create_path παίρνει ένα μονοπάτι σε αρχείο και δημιουργεί το αρχείο και κάθε φάκελο που δεν υπάρχει ήδη στο διάβα της.
Η paste_contents αντιγράφει τα δεδομένα στο μονοπάτι που της έχει δωθεί.


COMPILE & RUN
compilation :		make 
run : 				dataServer : 	./dataServer -p <port> -s <thread_pool_size> -q <queue_size> -b <block_size>	
									πχ.  ./dataServer -p 12400 -s 3 -q 2 -b 512
					remoteClient : 	./remoteClient -i <server_ip> -p <server_port> -d <directory>					
									πχ.  ./remoteClient -i 127.0.0.1 -p 12400 -d big_dir  ή  big_dir/dir3/folder5 
clean : 			make clean
					Διαγράφει όλα τα .ο, τα εκτελέσιμα dataServer και remoteClient και όλους τους δημιουργημένους φακέλους στον φάκελο ClientsFileSystems.

Στον φάκελο server υπάρχουν δύο φάκελοι για δοκιμή, big_dir και big_content.









